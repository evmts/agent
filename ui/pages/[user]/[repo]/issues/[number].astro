---
import Layout from "../../../../layouts/Layout.astro";
import Header from "../../../../components/Header.astro";
import Markdown from "../../../../components/Markdown.astro";
import CommentCard from "../../../../components/CommentCard.astro";
import MarkdownEditor from "../../../../components/MarkdownEditor.astro";
import IssueSidebar from "../../../../components/IssueSidebar.astro";
import IssueDependencies from "../../../../components/IssueDependencies.astro";
import Avatar from "../../../../components/Avatar.astro";
import RelativeTime from "../../../../components/RelativeTime.astro";
import Reactions from "../../../../components/Reactions.astro";
import ActivityItem from "../../../../components/ActivityItem.astro";
import { sql } from "../../../../lib/db";
import {
  getIssue,
  getComments,
  addComment,
  updateComment,
  deleteComment,
  updateIssue,
  closeIssue,
  reopenIssue,
  pinIssue,
  unpinIssue,
  getIssueCounts,
  getLabels,
  ensureIssuesRepo,
  getIssueEvents,
  listIssues,
} from "../../../../lib/git-issues";
import { saveMentionsForComment } from "../../../../lib/mentions-db";
import type { User, Repository, ReactionGroup } from "../../../../lib/types";

const { user: username, repo: reponame, number: issueNumber } = Astro.params;

if (!username || !reponame || !issueNumber) {
  return Astro.redirect('/404');
}

const [user] = await sql<User[]>`SELECT * FROM users WHERE username = ${username}`;
if (!user) return Astro.redirect("/404");

const [repo] = await sql<Repository[]>`
  SELECT * FROM repositories
  WHERE user_id = ${user.id} AND name = ${reponame}
`;

if (!repo) return Astro.redirect("/404");

// Ensure issues repo exists
await ensureIssuesRepo(username, reponame);

// Get issue from git
const gitIssue = await getIssue(username, reponame, parseInt(issueNumber));
if (!gitIssue) return Astro.redirect("/404");

// Get comments and events from git
const gitComments = await getComments(username, reponame, parseInt(issueNumber));
const events = await getIssueEvents(username, reponame, parseInt(issueNumber));

// Transform to match expected shapes
const issue = {
  ...gitIssue,
  issue_number: gitIssue.number,
  author_username: gitIssue.author.username,
  author_id: gitIssue.author.id,
  repository_id: repo.id,
  created_at: new Date(gitIssue.created_at),
  updated_at: new Date(gitIssue.updated_at),
  closed_at: gitIssue.closed_at ? new Date(gitIssue.closed_at) : null,
};

const comments = gitComments.map(c => ({
  ...c,
  author_username: c.author.username,
  author_id: c.author.id,
  issue_id: gitIssue.id,
  created_at: new Date(c.created_at),
}));

// Create a unified timeline of comments and events, sorted by date
type TimelineItem = { type: 'comment'; data: typeof comments[0] } | { type: 'event'; data: typeof events[0] };

const timeline: TimelineItem[] = [
  ...comments.map(c => ({ type: 'comment' as const, data: c })),
  ...events.map(e => ({ type: 'event' as const, data: e }))
].sort((a, b) => {
  const dateA = a.type === 'comment' ? a.data.created_at : a.data.created_at;
  const dateB = b.type === 'comment' ? b.data.created_at : b.data.created_at;
  return dateA.getTime() - dateB.getTime();
});

const users = await sql<User[]>`SELECT * FROM users ORDER BY username`;

const counts = await getIssueCounts(username, reponame);

// Get available labels
const availableLabels = await getLabels(username, reponame);

// Get all issues for dependency selection
const allIssues = await listIssues(username, reponame, "all");

// Get milestones for this repository
const milestones = await sql<Array<{ id: number; title: string; due_date: string | null; state: string }>>`
  SELECT id, title, due_date, state
  FROM milestones
  WHERE repository_id = ${repo.id}
  ORDER BY state DESC, due_date ASC NULLS LAST
`;

// Get current milestone if issue has one
let currentMilestone = null;
if (gitIssue.milestone) {
  [currentMilestone] = await sql<Array<{ id: number; title: string; due_date: string | null; state: string }>>`
    SELECT id, title, due_date, state
    FROM milestones
    WHERE id = (
      SELECT milestone_id FROM issues
      WHERE repository_id = ${repo.id} AND issue_number = ${parseInt(issueNumber)}
    )
  `;
}

// Fetch reactions for the issue
const issueReactions = await sql<Array<{ user_id: number; username: string; emoji: string }>>`
  SELECT r.user_id, u.username, r.emoji
  FROM reactions r
  JOIN users u ON r.user_id = u.id
  WHERE r.target_type = 'issue' AND r.target_id = ${parseInt(issueNumber)}
  ORDER BY r.created_at ASC
`;

// Group reactions by emoji
const issueReactionGroups: ReactionGroup[] = Object.values(
  issueReactions.reduce((acc, r) => {
    if (!acc[r.emoji]) {
      acc[r.emoji] = {
        emoji: r.emoji,
        count: 0,
        users: [],
        has_reacted: false,
      };
    }
    acc[r.emoji].count++;
    acc[r.emoji].users.push({ id: r.user_id, username: r.username });
    return acc;
  }, {} as Record<string, ReactionGroup>)
);

// Fetch reactions for all comments
const commentIds = comments.map(c => c.id);
const commentReactionsRaw = commentIds.length > 0 ? await sql<Array<{ target_id: number; user_id: number; username: string; emoji: string }>>`
  SELECT r.target_id, r.user_id, u.username, r.emoji
  FROM reactions r
  JOIN users u ON r.user_id = u.id
  WHERE r.target_type = 'comment' AND r.target_id = ANY(${commentIds})
  ORDER BY r.created_at ASC
` : [];

// Group reactions by comment and emoji
const commentReactions = commentReactionsRaw.reduce((acc, r) => {
  if (!acc[r.target_id]) {
    acc[r.target_id] = {};
  }
  if (!acc[r.target_id][r.emoji]) {
    acc[r.target_id][r.emoji] = {
      emoji: r.emoji,
      count: 0,
      users: [],
      has_reacted: false,
    };
  }
  acc[r.target_id][r.emoji].count++;
  acc[r.target_id][r.emoji].users.push({ id: r.user_id, username: r.username });
  return acc;
}, {} as Record<number, Record<string, ReactionGroup>>);

// Count pending landing requests
let landingCount = 0;
try {
  const [result] = await sql`
    SELECT COUNT(*) as count
    FROM landing_queue
    WHERE repository_id = ${repo.id} AND status = 'pending'
  `;
  landingCount = result?.count || 0;
} catch {
  // landing_queue table may not exist yet
}

let error = "";

if (Astro.request.method === "POST") {
  const formData = await Astro.request.formData();
  const action = formData.get("action") as string;

  if (action === "comment") {
    const authorId = formData.get("author_id") as string;
    const body = (formData.get("body") as string)?.trim();

    if (!authorId || !body) {
      error = "Comment cannot be empty";
    } else {
      try {
        // Get author info from DB
        const [author] = await sql<User[]>`SELECT * FROM users WHERE id = ${authorId}`;
        if (!author) {
          error = "Author not found";
        } else {
          const comment = await addComment(username, reponame, parseInt(issueNumber), {
            body,
            author: {
              id: parseInt(authorId),
              username: author.username,
            },
          });

          // Save mentions to database for notifications
          try {
            await saveMentionsForComment(repo.id, parseInt(issueNumber), comment.id.toString().padStart(3, "0"), body);
          } catch (mentionError) {
            console.error("Failed to save mentions:", mentionError);
            // Don't fail the whole request if mentions fail
          }

          return Astro.redirect(Astro.url.pathname);
        }
      } catch (e) {
        error = (e as Error).message;
      }
    }
  } else if (action === "close") {
    const actorIdStr = formData.get("author_id") as string;
    const actorId = actorIdStr ? parseInt(actorIdStr) : undefined;
    try {
      await closeIssue(username, reponame, parseInt(issueNumber), actorId);
      return Astro.redirect(Astro.url.pathname);
    } catch (e) {
      error = (e as Error).message;
    }
  } else if (action === "reopen") {
    const actorIdStr = formData.get("author_id") as string;
    const actorId = actorIdStr ? parseInt(actorIdStr) : undefined;
    try {
      await reopenIssue(username, reponame, parseInt(issueNumber), actorId);
      return Astro.redirect(Astro.url.pathname);
    } catch (e) {
      error = (e as Error).message;
    }
  } else if (action === "edit_comment") {
    const commentId = formData.get("comment_id") as string;
    const body = (formData.get("body") as string)?.trim();

    if (!commentId || !body) {
      error = "Comment body cannot be empty";
    } else {
      try {
        await updateComment(username, reponame, parseInt(issueNumber), parseInt(commentId), { body });
        return Astro.redirect(Astro.url.pathname);
      } catch (e) {
        error = (e as Error).message;
      }
    }
  } else if (action === "delete_comment") {
    const commentId = formData.get("comment_id") as string;

    if (!commentId) {
      error = "Comment ID is required";
    } else {
      try {
        await deleteComment(username, reponame, parseInt(issueNumber), parseInt(commentId));
        return Astro.redirect(Astro.url.pathname);
      } catch (e) {
        error = (e as Error).message;
      }
    }
  } else if (action === "edit_issue") {
    const title = (formData.get("title") as string)?.trim();
    const body = (formData.get("body") as string)?.trim();

    if (!title) {
      error = "Title cannot be empty";
    } else {
      try {
        await updateIssue(username, reponame, parseInt(issueNumber), { title, body });
        return Astro.redirect(Astro.url.pathname);
      } catch (e) {
        error = (e as Error).message;
      }
    }
  } else if (action === "pin") {
    try {
      await pinIssue(username, reponame, parseInt(issueNumber));
      return Astro.redirect(Astro.url.pathname);
    } catch (e) {
      error = (e as Error).message;
    }
  } else if (action === "unpin") {
    try {
      await unpinIssue(username, reponame, parseInt(issueNumber));
      return Astro.redirect(Astro.url.pathname);
    } catch (e) {
      error = (e as Error).message;
    }
  }
}

// Get current user from cookie (mock for now - replace with actual auth)
let currentUserId: number | undefined;
const cookies = Astro.cookies;
const authCookie = cookies.get("auth_user");
if (authCookie) {
  try {
    const authData = JSON.parse(authCookie.value);
    currentUserId = authData.id;
  } catch {
    // Invalid cookie
  }
}
---

<Layout title={`${issue.title} Â· Issue #${issue.issue_number} Â· plue`}>
  <Header />

  <div class="breadcrumb">
    <a href={`/${username}`}>{username}</a>
    <span class="sep">/</span>
    <a href={`/${username}/${reponame}`}>{reponame}</a>
    <span class="sep">/</span>
    <a href={`/${username}/${reponame}/issues`}>issues</a>
    <span class="sep">/</span>
    <span class="current">#{issue.issue_number}</span>
  </div>

  <nav class="repo-nav">
    <a href={`/${username}/${reponame}`}>Code</a>
    <a href={`/${username}/${reponame}/issues`} class="active">
      Issues
      {counts.open > 0 && <span class="badge">{counts.open}</span>}
    </a>
    <a href={`/${username}/${reponame}/landing`}>
      Landing
      {landingCount > 0 && <span class="badge">{landingCount}</span>}
    </a>
    <a href={`/${username}/${reponame}/bookmarks`}>Bookmarks</a>
    <a href={`/${username}/${reponame}/changes/${repo.default_branch || 'main'}`}>Changes</a>
  </nav>

  <div class="container">
    <div class="issue-header mb-3">
      <div class="flex-between mb-1">
        <h1 class="page-title">{issue.title}</h1>
        <span class:list={["issue-state", issue.state]}>{issue.state}</span>
      </div>
      <div class="issue-header-meta">
        <Avatar user={{ username: issue.author_username || 'unknown' }} size="sm" />
        <p class="text-muted text-sm">
          #{issue.issue_number} opened by <strong>{issue.author_username}</strong> <RelativeTime date={issue.created_at} />
        </p>
      </div>
    </div>

    <div class="issue-layout">
      <div class="issue-main">
        {issue.body && (
          <div class="comment" id="issue-body">
            <div class="comment-header">
              <Avatar user={{ username: issue.author_username || 'unknown' }} size="sm" />
              <strong>{issue.author_username}</strong>
              <span class="time">Â· opened this issue</span>
              {currentUserId && currentUserId === issue.author_id && (
                <div class="comment-actions">
                  <button class="btn-text edit-issue-btn" type="button">Edit</button>
                </div>
              )}
            </div>
            <div class="issue-body-content">
              <Markdown content={issue.body} owner={username} repo={reponame} />
            </div>
            <Reactions
              targetType="issue"
              targetId={parseInt(issueNumber)}
              user={username}
              repo={reponame}
              issueNumber={parseInt(issueNumber)}
              currentUserId={currentUserId}
              reactions={issueReactionGroups}
            />
            {currentUserId && currentUserId === issue.author_id && (
              <div class="issue-edit" style="display: none;">
                <form method="POST" class="edit-form">
                  <input type="hidden" name="action" value="edit_issue" />
                  <div class="form-group">
                    <label for="edit-title">Title</label>
                    <input type="text" name="title" id="edit-title" value={issue.title} required />
                  </div>
                  <div class="form-group">
                    <label for="edit-body">Body</label>
                    <MarkdownEditor
                      name="body"
                      id="edit-body"
                      initialValue={issue.body}
                      height="200px"
                    />
                  </div>
                  <div class="flex gap-1 mt-1">
                    <button type="submit" class="btn btn-primary">Save</button>
                    <button type="button" class="btn cancel-edit-issue">Cancel</button>
                  </div>
                </form>
              </div>
            )}
          </div>
        )}

        {timeline.map((item) => (
          item.type === 'comment' ? (
            <CommentCard
              comment={item.data}
              owner={username}
              repo={reponame}
              currentUserId={currentUserId}
              issueNumber={parseInt(issueNumber)}
              reactions={Object.values(commentReactions[item.data.id] || {})}
            />
          ) : (
            <ActivityItem event={item.data} />
          )
        ))}

        <div class="add-comment mt-3">
          <h2 class="mb-2">Add a comment</h2>

          {error && (
            <div class="error-banner mb-2">
              {error}
            </div>
          )}

          <form method="POST">
            <input type="hidden" name="action" value="comment" />

            <div class="form-group">
              <label for="author_id">Comment as</label>
              <select name="author_id" id="author_id" required>
                {users.map((u) => (
                  <option value={u.id}>{u.username}</option>
                ))}
              </select>
            </div>

            <div class="form-group">
              <label for="body">Comment</label>
              <MarkdownEditor
                name="body"
                id="body"
                required
                placeholder="Leave a comment..."
                height="200px"
              />
            </div>

            <div class="flex gap-1">
              <button type="submit" class="btn btn-primary">Comment</button>

              {issue.state === "open" ? (
                <button type="submit" name="action" value="close" class="btn btn-danger">
                  Close issue
                </button>
              ) : (
                <button type="submit" name="action" value="reopen" class="btn">
                  Reopen issue
                </button>
              )}

              {issue.is_pinned ? (
                <button type="submit" name="action" value="unpin" class="btn">
                  ðŸ“Œ Unpin
                </button>
              ) : (
                <button type="submit" name="action" value="pin" class="btn">
                  ðŸ“Œ Pin
                </button>
              )}
            </div>
          </form>
        </div>
      </div>

      <div class="issue-sidebar-wrapper">
        <IssueSidebar issue={issue} users={users} availableLabels={availableLabels} milestones={milestones} currentMilestone={currentMilestone} allIssues={allIssues.map(i => ({ number: i.number, title: i.title, state: i.state }))} />
        <IssueDependencies issue={issue} allIssues={allIssues.map(i => ({ number: i.number, title: i.title, state: i.state }))} />
      </div>
    </div>
  </div>
</Layout>

<style>
  .issue-header {
    padding-bottom: 16px;
    border-bottom: 1px solid var(--border);
  }

  .issue-header-meta {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .error-banner {
    padding: 12px 16px;
    background: rgba(255, 68, 68, 0.1);
    border: 1px solid rgba(255, 68, 68, 0.3);
    border-radius: var(--radius);
    color: var(--error);
    font-size: 13px;
  }

  .issue-layout {
    display: grid;
    grid-template-columns: 1fr 300px;
    gap: 32px;
    align-items: start;
  }

  .issue-main {
    min-width: 0;
  }

  .issue-sidebar-wrapper {
    position: sticky;
    top: 80px;
  }

  @media (max-width: 968px) {
    .issue-layout {
      grid-template-columns: 1fr;
    }

    .issue-sidebar-wrapper {
      position: static;
      order: 2;
    }

    .issue-main {
      order: 1;
    }
  }

  .comment-actions {
    margin-left: auto;
    display: flex;
    gap: 8px;
  }

  .btn-text {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 4px 8px;
    font-size: 13px;
    font-family: inherit;
  }

  .btn-text:hover {
    color: var(--text);
  }

  .issue-edit {
    margin-top: 12px;
  }
</style>

<script>
  document.addEventListener("astro:page-load", () => {
    // Handle edit issue button
    const editIssueBtn = document.querySelector(".edit-issue-btn");
    if (editIssueBtn) {
      editIssueBtn.addEventListener("click", () => {
        const issueBody = document.querySelector("#issue-body");
        if (!issueBody) return;

        const content = issueBody.querySelector(".issue-body-content") as HTMLElement;
        const editForm = issueBody.querySelector(".issue-edit") as HTMLElement;

        if (content && editForm) {
          content.style.display = "none";
          editForm.style.display = "block";
        }
      });
    }

    // Handle cancel edit issue button
    const cancelEditIssueBtn = document.querySelector(".cancel-edit-issue");
    if (cancelEditIssueBtn) {
      cancelEditIssueBtn.addEventListener("click", () => {
        const issueBody = document.querySelector("#issue-body");
        if (!issueBody) return;

        const content = issueBody.querySelector(".issue-body-content") as HTMLElement;
        const editForm = issueBody.querySelector(".issue-edit") as HTMLElement;

        if (content && editForm) {
          content.style.display = "block";
          editForm.style.display = "none";
        }
      });
    }
  });
</script>
