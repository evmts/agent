---
import Layout from "../../../../layouts/Layout.astro";
import Header from "../../../../components/Header.astro";
import Markdown from "../../../../components/Markdown.astro";
import CommentCard from "../../../../components/CommentCard.astro";
import MarkdownEditor from "../../../../components/MarkdownEditor.astro";
import IssueSidebar from "../../../../components/IssueSidebar.astro";
import { sql } from "../../../../lib/db";
import {
  getIssue,
  getComments,
  addComment,
  closeIssue,
  reopenIssue,
  getIssueCounts,
  ensureIssuesRepo,
} from "../../../../lib/git-issues";
import type { User, Repository } from "../../../../lib/types";

const { user: username, repo: reponame, number: issueNumber } = Astro.params;

if (!username || !reponame || !issueNumber) {
  return Astro.redirect('/404');
}

const [user] = await sql<User[]>`SELECT * FROM users WHERE username = ${username}`;
if (!user) return Astro.redirect("/404");

const [repo] = await sql<Repository[]>`
  SELECT * FROM repositories
  WHERE user_id = ${user.id} AND name = ${reponame}
`;

if (!repo) return Astro.redirect("/404");

// Ensure issues repo exists
await ensureIssuesRepo(username, reponame);

// Get issue from git
const gitIssue = await getIssue(username, reponame, parseInt(issueNumber));
if (!gitIssue) return Astro.redirect("/404");

// Get comments from git
const gitComments = await getComments(username, reponame, parseInt(issueNumber));

// Transform to match expected shapes
const issue = {
  ...gitIssue,
  issue_number: gitIssue.number,
  author_username: gitIssue.author.username,
  author_id: gitIssue.author.id,
  repository_id: repo.id,
  created_at: new Date(gitIssue.created_at),
  updated_at: new Date(gitIssue.updated_at),
  closed_at: gitIssue.closed_at ? new Date(gitIssue.closed_at) : null,
};

const comments = gitComments.map(c => ({
  ...c,
  author_username: c.author.username,
  author_id: c.author.id,
  issue_id: gitIssue.id,
  created_at: new Date(c.created_at),
}));

const users = await sql<User[]>`SELECT * FROM users ORDER BY username`;

const counts = await getIssueCounts(username, reponame);

// Count pending landing requests
let landingCount = 0;
try {
  const [result] = await sql`
    SELECT COUNT(*) as count
    FROM landing_queue
    WHERE repository_id = ${repo.id} AND status = 'pending'
  `;
  landingCount = result?.count || 0;
} catch {
  // landing_queue table may not exist yet
}

let error = "";

if (Astro.request.method === "POST") {
  const formData = await Astro.request.formData();
  const action = formData.get("action") as string;

  if (action === "comment") {
    const authorId = formData.get("author_id") as string;
    const body = (formData.get("body") as string)?.trim();

    if (!authorId || !body) {
      error = "Comment cannot be empty";
    } else {
      try {
        // Get author info from DB
        const [author] = await sql<User[]>`SELECT * FROM users WHERE id = ${authorId}`;
        if (!author) {
          error = "Author not found";
        } else {
          await addComment(username, reponame, parseInt(issueNumber), {
            body,
            author: {
              id: parseInt(authorId),
              username: author.username,
            },
          });
          return Astro.redirect(Astro.url.pathname);
        }
      } catch (e) {
        error = (e as Error).message;
      }
    }
  } else if (action === "close") {
    try {
      await closeIssue(username, reponame, parseInt(issueNumber));
      return Astro.redirect(Astro.url.pathname);
    } catch (e) {
      error = (e as Error).message;
    }
  } else if (action === "reopen") {
    try {
      await reopenIssue(username, reponame, parseInt(issueNumber));
      return Astro.redirect(Astro.url.pathname);
    } catch (e) {
      error = (e as Error).message;
    }
  }
}

function formatDate(date: string | Date): string {
  return new Date(date).toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric",
  });
}
---

<Layout title={`${issue.title} · Issue #${issue.issue_number} · plue`}>
  <Header />

  <div class="breadcrumb">
    <a href={`/${username}`}>{username}</a>
    <span class="sep">/</span>
    <a href={`/${username}/${reponame}`}>{reponame}</a>
    <span class="sep">/</span>
    <a href={`/${username}/${reponame}/issues`}>issues</a>
    <span class="sep">/</span>
    <span class="current">#{issue.issue_number}</span>
  </div>

  <nav class="repo-nav">
    <a href={`/${username}/${reponame}`}>Code</a>
    <a href={`/${username}/${reponame}/issues`} class="active">
      Issues
      {counts.open > 0 && <span class="badge">{counts.open}</span>}
    </a>
    <a href={`/${username}/${reponame}/landing`}>
      Landing
      {landingCount > 0 && <span class="badge">{landingCount}</span>}
    </a>
    <a href={`/${username}/${reponame}/bookmarks`}>Bookmarks</a>
    <a href={`/${username}/${reponame}/changes/${repo.default_branch || 'main'}`}>Changes</a>
  </nav>

  <div class="container">
    <div class="issue-header mb-3">
      <div class="flex-between mb-1">
        <h1 class="page-title">{issue.title}</h1>
        <span class:list={["issue-state", issue.state]}>{issue.state}</span>
      </div>
      <p class="text-muted text-sm">
        #{issue.issue_number} opened by <strong>{issue.author_username}</strong> on {formatDate(issue.created_at)}
      </p>
    </div>

    <div class="issue-layout">
      <div class="issue-main">
        {issue.body && (
          <div class="comment">
            <div class="comment-header">
              <strong>{issue.author_username}</strong>
              <span class="time">· opened this issue</span>
            </div>
            <div class="comment-body">
              <Markdown content={issue.body} owner={username} repo={reponame} />
            </div>
          </div>
        )}

        {comments.map((comment) => (
          <CommentCard comment={comment} />
        ))}

        <div class="add-comment mt-3">
          <h2 class="mb-2">Add a comment</h2>

          {error && (
            <div class="error-banner mb-2">
              {error}
            </div>
          )}

          <form method="POST">
            <input type="hidden" name="action" value="comment" />

            <div class="form-group">
              <label for="author_id">Comment as</label>
              <select name="author_id" id="author_id" required>
                {users.map((u) => (
                  <option value={u.id}>{u.username}</option>
                ))}
              </select>
            </div>

            <div class="form-group">
              <label for="body">Comment</label>
              <MarkdownEditor
                name="body"
                id="body"
                required
                placeholder="Leave a comment..."
                height="200px"
              />
            </div>

            <div class="flex gap-1">
              <button type="submit" class="btn btn-primary">Comment</button>

              {issue.state === "open" ? (
                <button type="submit" name="action" value="close" class="btn btn-danger">
                  Close issue
                </button>
              ) : (
                <button type="submit" name="action" value="reopen" class="btn">
                  Reopen issue
                </button>
              )}
            </div>
          </form>
        </div>
      </div>

      <div class="issue-sidebar-wrapper">
        <IssueSidebar issue={issue} users={users} />
      </div>
    </div>
  </div>
</Layout>

<style>
  .issue-header {
    padding-bottom: 16px;
    border-bottom: 1px solid var(--border);
  }

  .error-banner {
    padding: 12px 16px;
    background: rgba(255, 68, 68, 0.1);
    border: 1px solid rgba(255, 68, 68, 0.3);
    border-radius: var(--radius);
    color: var(--error);
    font-size: 13px;
  }

  .issue-layout {
    display: grid;
    grid-template-columns: 1fr 300px;
    gap: 32px;
    align-items: start;
  }

  .issue-main {
    min-width: 0;
  }

  .issue-sidebar-wrapper {
    position: sticky;
    top: 80px;
  }

  @media (max-width: 968px) {
    .issue-layout {
      grid-template-columns: 1fr;
    }

    .issue-sidebar-wrapper {
      position: static;
      order: 2;
    }

    .issue-main {
      order: 1;
    }
  }
</style>
