---
import Layout from "../../../layouts/Layout.astro";
import Header from "../../../components/Header.astro";
import FileTree from "../../../components/FileTree.astro";
import Markdown from "../../../components/Markdown.astro";
import TopicBadge from "../../../components/TopicBadge.astro";
import { sql } from "../../../lib/db";
import { getTree, getFileContent, getCloneUrl, getDefaultBookmark } from "../../../lib/jj";
import type { User, Repository } from "../../../lib/types";

const { user: username, repo: reponame } = Astro.params;

if (!username || !reponame) {
  return Astro.redirect('/404');
}

const [user] = await sql<User[]>`SELECT * FROM users WHERE username = ${username}`;
if (!user) return Astro.redirect("/404");

const [repo] = await sql<Repository[]>`
  SELECT * FROM repositories
  WHERE user_id = ${user.id} AND name = ${reponame}
`;

if (!repo) return Astro.redirect("/404");

const defaultBookmark = await getDefaultBookmark(username, reponame);
const tree = await getTree(username, reponame, defaultBookmark);

// Try to get README
let readme = "";
const readmeFile = tree.find(
  (f) => f.name.toLowerCase().startsWith("readme") && f.type === "blob"
);
if (readmeFile) {
  readme = (await getFileContent(username, reponame, defaultBookmark, readmeFile.name)) || "";
}

const cloneUrl = getCloneUrl(username, reponame);

const [{ count: issueCount }] = await sql`
  SELECT COUNT(*) as count FROM issues WHERE repository_id = ${repo.id} AND state = 'open'
`;

// Count pending landing requests
let landingCount = 0;
try {
  const [result] = await sql`
    SELECT COUNT(*) as count
    FROM landing_queue
    WHERE repository_id = ${repo.id} AND status = 'pending'
  `;
  landingCount = result?.count || 0;
} catch {
  // landing_queue table may not exist yet
}

// Get star count
const [{ count: starCount }] = await sql`
  SELECT COUNT(*) as count FROM stars WHERE repository_id = ${repo.id}
`;

// Count running/failing workflows
let workflowStatus = { running: 0, failing: 0 };
try {
  const [runningResult] = await sql`
    SELECT COUNT(*) as count
    FROM workflow_runs
    WHERE repository_id = ${repo.id} AND status = 6
  `;
  workflowStatus.running = runningResult?.count || 0;

  const [failingResult] = await sql`
    SELECT COUNT(*) as count
    FROM workflow_runs
    WHERE repository_id = ${repo.id} AND status = 2
    AND created_at > NOW() - INTERVAL '24 hours'
  `;
  workflowStatus.failing = failingResult?.count || 0;
} catch {
  // workflow tables may not exist yet
}
---

<Layout title={`${username}/${reponame} ¬∑ plue`}>
  <Header />

  <div class="breadcrumb">
    <a href={`/${username}`}>{username}</a>
    <span class="sep">/</span>
    <span class="current">{reponame}</span>
  </div>

  <nav class="repo-nav">
    <a href={`/${username}/${reponame}`} class="active">Code</a>
    <a href={`/${username}/${reponame}/issues`}>
      Issues
      {Number(issueCount) > 0 && <span class="badge">{issueCount}</span>}
    </a>
    <a href={`/${username}/${reponame}/landing`}>
      Landing
      {Number(landingCount) > 0 && <span class="badge">{landingCount}</span>}
    </a>
    <a href={`/${username}/${reponame}/workflows`}>
      Workflows
      {workflowStatus.running > 0 && <span class="badge badge-running">{workflowStatus.running}</span>}
      {workflowStatus.failing > 0 && <span class="badge badge-error">{workflowStatus.failing}</span>}
    </a>
    <a href={`/${username}/${reponame}/bookmarks`}>Bookmarks</a>
    <a href={`/${username}/${reponame}/changes/${defaultBookmark}`}>Changes</a>
    <a href={`/${username}/${reponame}/operations`}>Operations</a>
    <a href={`/${username}/${reponame}/settings`}>Settings</a>
  </nav>

  <div class="container">
    <div class="repo-header mb-3">
      <div class="repo-info">
        {repo.description && <p class="description mb-2">{repo.description}</p>}

        {repo.topics && repo.topics.length > 0 && (
          <div class="topics mb-2">
            {repo.topics.map((topic) => (
              <TopicBadge topic={topic} />
            ))}
          </div>
        )}
      </div>

      <div class="repo-actions">
        <button id="star-btn" class="btn btn-sm" data-username={username} data-repo={reponame}>
          <span id="star-icon">‚òÜ</span>
          <span id="star-text">Star</span>
          <span id="star-count" class="badge">{starCount}</span>
        </button>

        <div class="watch-dropdown">
          <button id="watch-btn" class="btn btn-sm">
            <span id="watch-icon">üëÅ</span>
            <span id="watch-text">Watch</span>
          </button>
          <div id="watch-menu" class="dropdown-menu">
            <button data-level="all">Watch all activity</button>
            <button data-level="releases">Watch releases only</button>
            <button data-level="ignore">Unwatch</button>
          </div>
        </div>
      </div>
    </div>

    <div class="clone-url mb-3">
      <code>{cloneUrl}</code>
      <button class="btn btn-sm" onclick="navigator.clipboard.writeText(this.previousElementSibling.textContent)">
        Copy
      </button>
      <a href="/settings/ssh-keys" class="ssh-key-link">Add SSH key</a>
    </div>

    <FileTree tree={tree} user={username} repo={reponame} branch={defaultBookmark} />

    {readme && (
      <div class="mt-3">
        <Markdown content={readme} />
      </div>
    )}
  </div>
</Layout>

<style>
  .description {
    font-size: 14px;
  }
  .topics {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }
  .ssh-key-link {
    margin-left: 0.5rem;
    font-size: 12px;
    color: var(--link);
  }
  .ssh-key-link:hover {
    text-decoration: underline;
  }

  .repo-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--border);
  }

  .repo-info {
    flex: 1;
  }

  .repo-actions {
    display: flex;
    gap: 0.5rem;
    align-items: center;
  }

  .repo-actions .btn {
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }

  .repo-actions .badge {
    background: var(--bg-secondary);
    padding: 0.125rem 0.375rem;
    border-radius: 2px;
    font-size: 11px;
    font-weight: normal;
  }

  .watch-dropdown {
    position: relative;
  }

  .dropdown-menu {
    display: none;
    position: absolute;
    top: 100%;
    right: 0;
    margin-top: 0.25rem;
    background: var(--bg);
    border: 1px solid var(--border);
    min-width: 200px;
    z-index: 100;
  }

  .dropdown-menu.show {
    display: block;
  }

  .dropdown-menu button {
    display: block;
    width: 100%;
    padding: 0.5rem 1rem;
    text-align: left;
    background: none;
    border: none;
    cursor: pointer;
    font-size: 14px;
  }

  .dropdown-menu button:hover {
    background: var(--bg-secondary);
  }

  #star-btn.starred #star-icon::before {
    content: "‚òÖ";
  }
</style>

<script>
  // Star functionality
  const starBtn = document.getElementById("star-btn");
  const starIcon = document.getElementById("star-icon");
  const starText = document.getElementById("star-text");
  const starCountEl = document.getElementById("star-count");

  // Watch functionality
  const watchBtn = document.getElementById("watch-btn");
  const watchMenu = document.getElementById("watch-menu");
  const watchText = document.getElementById("watch-text");

  if (starBtn) {
    const username = starBtn.dataset.username;
    const repo = starBtn.dataset.repo;

    // Load initial star status
    fetch(`/${username}/${repo}/star/status`)
      .then(res => res.json())
      .then(data => {
        if (data.starred) {
          starBtn.classList.add("starred");
          starIcon.textContent = "‚òÖ";
          starText.textContent = "Unstar";
        }
        if (data.starCount !== undefined) {
          starCountEl.textContent = data.starCount;
        }
      })
      .catch(err => console.error("Failed to load star status:", err));

    // Star/unstar handler
    starBtn.addEventListener("click", async () => {
      const isStarred = starBtn.classList.contains("starred");
      const method = isStarred ? "DELETE" : "POST";

      try {
        const res = await fetch(`/${username}/${repo}/star`, { method });
        const data = await res.json();

        if (res.ok) {
          if (isStarred) {
            starBtn.classList.remove("starred");
            starIcon.textContent = "‚òÜ";
            starText.textContent = "Star";
          } else {
            starBtn.classList.add("starred");
            starIcon.textContent = "‚òÖ";
            starText.textContent = "Unstar";
          }

          if (data.starCount !== undefined) {
            starCountEl.textContent = data.starCount;
          }
        } else if (res.status === 401) {
          window.location.href = "/login";
        }
      } catch (err) {
        console.error("Failed to toggle star:", err);
      }
    });
  }

  // Watch dropdown
  if (watchBtn && watchMenu) {
    const username = watchBtn.closest(".repo-actions").querySelector("#star-btn")?.dataset.username;
    const repo = watchBtn.closest(".repo-actions").querySelector("#star-btn")?.dataset.repo;

    // Load initial watch status
    if (username && repo) {
      fetch(`/${username}/${repo}/watch/status`)
        .then(res => res.json())
        .then(data => {
          if (data.watching) {
            watchText.textContent = data.level === "all" ? "Watching" : "Watching releases";
          }
        })
        .catch(err => console.error("Failed to load watch status:", err));
    }

    // Toggle dropdown
    watchBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      watchMenu.classList.toggle("show");
    });

    // Close dropdown when clicking outside
    document.addEventListener("click", () => {
      watchMenu.classList.remove("show");
    });

    // Handle watch level selection
    watchMenu.querySelectorAll("button").forEach((btn) => {
      btn.addEventListener("click", async (e) => {
        e.stopPropagation();
        const level = btn.dataset.level;

        if (level === "ignore") {
          // Unwatch
          try {
            const res = await fetch(`/${username}/${repo}/watch`, { method: "DELETE" });
            if (res.ok) {
              watchText.textContent = "Watch";
              watchMenu.classList.remove("show");
            } else if (res.status === 401) {
              window.location.href = "/login";
            }
          } catch (err) {
            console.error("Failed to unwatch:", err);
          }
        } else {
          // Watch with level
          try {
            const res = await fetch(`/${username}/${repo}/watch`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ level }),
            });

            if (res.ok) {
              watchText.textContent = level === "all" ? "Watching" : "Watching releases";
              watchMenu.classList.remove("show");
            } else if (res.status === 401) {
              window.location.href = "/login";
            }
          } catch (err) {
            console.error("Failed to watch:", err);
          }
        }
      });
    });
  }
</script>