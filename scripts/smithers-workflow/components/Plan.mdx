PLANNING PHASE — Ticket: {props.ticketId} — {props.ticketTitle}

Create detailed implementation plan based on research.

TICKET DESCRIPTION:
{props.ticketDescription}

ACCEPTANCE CRITERIA:
{props.acceptanceCriteria}

RESEARCH SUMMARY:
{props.researchSummary}

Read full research context: {props.contextFilePath}

PLANNING RULES:
1. Cover all affected layers (check ticket's `layers` field — may be Zig-only or full e2e)
2. Each step atomic — one logical change
3. Ordering: plan doc FIRST → tests SECOND (TDD) → implementation THIRD → user-facing docs LAST (after tests green)
4. Consider dependency order — what must exist before what?
5. Identify exact files to create + modify
6. Consider integration with existing code
7. Include tests appropriate to layers touched:
   - Zig unit tests for core logic
   - Swift XCUITest for native UI features
   - Playwright e2e tests for web features

ARCHITECTURE PRINCIPLES:
- libsmithers (Zig) = source of truth for all business logic
- Use dependency injection for platform-specific concerns (SQLite, HTTP, filesystem)
- Keep Zig platform-agnostic (theoretically WASM-compilable)
- Follow Ghostty code patterns + style

Write plan to docs/plans/{props.ticketId}.md (create docs/plans if missing)

**REQUIRED OUTPUT** — JSON matching this schema:
{props.schema}
DO NOT skip JSON output. Workflow fails without it.
